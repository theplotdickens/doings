<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL FIX: Disabled user scaling (pinch-to-zoom) for stable mobile interaction -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shared Draggable Image Tiles</title>
    
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* FIX: Ensure HTML and Body use full height and prevent overflow for mobile stability */
        html, body {
            height: 100%;
            overflow: hidden; 
        }

        body {
            font-family: 'Inter', sans-serif;
            background-image: url('https://raw.githubusercontent.com/theplotdickens/doings/main/texture_forest_floor_1950_1_thumbnail.jpg');
            background-repeat: repeat;
            background-color: #f0f3f6; /* Fallback color */
            background-size: 200px 200px; 
            min-height: 100vh;
            margin: 0;
            /* Prevents common default browser touch gestures like pan/zoom */
            touch-action: none; 
        }
        #canvas-container {
             position: absolute;
             inset: 0;
             width: 100%;
             height: 100%;
        }
        
        .draggable-tile {
            position: absolute;
            user-select: none;
            cursor: grab;
            transition: box-shadow 0.3s ease, opacity 0.3s ease, transform 0.1s ease;
            z-index: 10; 
            /* This is critical for mobile image stability: ensure background image fits */
            background-size: contain; 
            background-repeat: no-repeat;
            background-position: center;
            background-color: #3b82f6; 
            border-radius: 0; 
            will-change: transform;
        }
        
        .draggable-tile:active, .draggable-tile.active-drag-state {
            cursor: grabbing;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); 
            z-index: 20; 
            transform: scale(1.01); 
        }
        
        /* --- NEW PUSHPIN STYLING --- */
        .pushpin {
            position: absolute;
            width: 24px; 
            height: 24px;
            /* Raw URL for the pushpin image */
            background-image: url('https://raw.githubusercontent.com/theplotdickens/doings/main/pushpin%20png.png');
            background-size: cover;
            background-repeat: no-repeat;
            z-index: 21; /* Ensure pins are above the tile */
            pointer-events: none; /* Pins should not interfere with dragging the tile */
        }
        /* Offset by half the width/height to center the pin on the corner */
        .pushpin.top-left { top: -12px; left: -12px; }
        .pushpin.top-right { top: -12px; right: -12px; }
        .pushpin.bottom-left { bottom: -12px; left: -12px; }
        .pushpin.bottom-right { bottom: -12px; right: -12px; }
        /* --- END PUSHPIN STYLING --- */


        .prompt-modal-overlay {
            position: fixed; 
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 30;
            overflow-y: auto; 
            padding: 20px 0;
        }

        .size-rect-sm {
            width: 192px; 
            height: 240px; 
        }
        @media (min-width: 640px) {
            .size-rect-lg {
                width: 400px; 
                height: 500px;
            }
        }
        
        .info-tag {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.9); 
            color: white;
            padding: 8px; 
            font-size: 0.75rem; 
            line-height: 1rem;
            text-align: center;
            opacity: 0;
            transform: translateY(100%); 
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 15; 
            pointer-events: none; 
        }
        .info-tag.visible {
            opacity: 1;
            transform: translateY(0); 
            pointer-events: auto; 
        }
        .info-toggle-button {
            position: absolute;
            bottom: 0px; 
            right: 0px; 
            background-color: rgba(60, 60, 60, 0.8); 
            color: white;
            border: none;
            width: 30px; 
            height: 30px; 
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem; 
            cursor: pointer;
            z-index: 25; 
            transition: background-color 0.2s ease;
        }
        .info-toggle-button:hover {
            background-color: rgba(90, 90, 90, 0.9);
        }
    </style>
</head>
<body onresize="renderAllTiles()">
    
    <!-- Main container for all draggable tiles -->
    <section id="canvas-container"></section>

    <!-- INPUT PROMPT MODAL: Visible until the user creates a tile -->
    <div id="input-prompt-modal" class="prompt-modal-overlay">
        <div class="w-full max-w-sm mx-4 p-6 bg-white shadow-xl rounded-xl transform transition-all pointer-events-auto">
            <div class="space-y-4">
                <p class="text-xl font-bold text-gray-800 text-center">Create Your Image Tile</p>
                <!-- Status text for Firebase initialization -->
                <p class="text-xs text-center text-gray-500 break-all" id="user-status-text">
                    Status: Connecting to services...
                </p>

                <input
                    type="text"
                    id="name-input"
                    placeholder="Enter your display name (max 15 chars)"
                    class="w-full px-3 py-2 border border-gray-400 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                    autocomplete="off"
                    maxlength="15"
                >
                
                <!-- Image Upload Section -->
                <div class="flex flex-col space-y-2">
                    <p class="text-sm font-medium text-gray-600">Upload and Compress Image (PNG/JPG)</p>
                    <input type="file" id="image-upload" accept="image/png, image/jpeg" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                    
                    <div id="image-preview" class="w-16 h-20 border-2 border-dashed border-gray-300 rounded-lg mx-auto image-preview mt-2 bg-gray-100 flex items-center justify-center text-xs text-gray-500">
                        Preview
                    </div>
                    <p id="compression-status" class="text-[10px] text-center text-red-500 hidden">Compressing...</p>
                </div>

                <button
                    id="submit-button"
                    class="w-full bg-blue-600 text-white py-2 rounded-lg font-medium hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-md"
                    disabled
                >
                    Create Tile
                </button>
            </div>
        </div>
    </div>
    
    <script type="module">
        // --- Firebase Imports (Required for structure) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =========================================================================================================
        // ðŸš€ MANUAL FIREBASE CONFIGURATION FALLBACK ðŸš€
        // =========================================================================================================
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 
        
        // Manual fallbacks used to fix the initialization error
        const manualProjectIdFallback = "doings-7717f"; 
        const manualApiKeyFallback = "AIzaSyBm425N7LfOy5M2bwCEA_x76qDj-W5O1WM"; 
        
        // --- Global Firebase State Variables ---
        let app = null;
        let db = null;
        let auth = null;
        let userId = null; 
        let authReady = false; 
        
        // --- Global App State & DOM Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const createPromptModal = document.getElementById('input-prompt-modal');
        const userStatusText = document.getElementById('user-status-text');
        
        let allTiles = new Map(); 
        let uploadedBase64Image = null; 
        
        // Drag limit constants
        const MAX_DRAG_SESSIONS = 6;
        const COOLDOWN_DURATION_MS = 60000;
        
        // Drag State Variables
        let isDragging = false;
        let activeTileElement = null;
        let activeTileId = null;
        let offsetX = 0;
        let offsetY = 0;
        
        // NEW SIZE CONSTANTS (4:5 Portrait Ratio, max 400x500)
        const TILE_WIDTH_SM = 192; 
        const TILE_HEIGHT_SM = 240; 
        const TILE_WIDTH_LG = 400; 
        const TILE_HEIGHT_LG = 500; 
        
        const TILE_BASE_CLASSES = "shadow-2xl draggable-tile"; 
        const TILE_SIZE_CLASSES = "size-rect-sm sm:size-rect-lg"; 

        // --- Utility Functions ---
        
        /**
         * Resizes and compresses an image file using canvas to ensure it stays
         * well under the 1MB Firestore document limit.
         */
        function resizeAndCompressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);

                reader.onload = (readerEvent) => {
                    const img = new Image();
                    img.src = readerEvent.target.result;
                    
                    img.onload = () => {
                        const MAX_DIMENSION = 800; // Max width/height dimension in pixels
                        const MIME_TYPE = 'image/jpeg';
                        const QUALITY = 0.7; // 70% compression quality

                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions while maintaining aspect ratio
                        if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                            if (width > height) {
                                height = Math.round(height * (MAX_DIMENSION / width));
                                width = MAX_DIMENSION;
                            } else {
                                width = Math.round(width * (MAX_DIMENSION / height));
                                height = MAX_DIMENSION;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert canvas content to compressed Base64
                        const dataUrl = canvas.toDataURL(MIME_TYPE, QUALITY);
                        resolve(dataUrl);
                    };

                    img.onerror = (e) => reject("Image loading error.");
                };
                reader.onerror = (e) => reject("File reading error.");
            });
        }

        /**
         * Returns the current tile dimensions based on viewport size.
         */
        window.getCurrentTileDimensions = function() {
            if (window.innerWidth >= 640) { // Tailwind 'sm' breakpoint
                return { width: TILE_WIDTH_LG, height: TILE_HEIGHT_LG };
            }
            return { width: TILE_WIDTH_SM, height: TILE_HEIGHT_SM };
        };
        
        function getTileDocRef(tileId) {
            if (!db) return null;
            // Document path: /artifacts/{appId}/public/data/shared_tiles/{tileId}
            return doc(db, 'artifacts', appId, 'public', 'data', 'shared_tiles', tileId); 
        }

        async function saveTile(data) {
            const tileId = data.creatorId || userId;
            if (!tileId) return console.error("Cannot save tile: missing ID.");

            if (!userId || !db) {
                 console.error("Save blocked: Firebase services are not ready or user is unauthorized.");
                 return; 
            }

            const tileRef = getTileDocRef(tileId);
            try {
                const size = JSON.stringify(data.base64Image || '').length;
                if (size > 1024 * 700) { 
                     console.error("Compressed image is still too large! Size:", size, "bytes");
                     return;
                }
                await setDoc(tileRef, data, { merge: true });
            } catch (error) {
                console.error("Error saving tile data to Firestore:", error);
            }
        }
        
        /**
         * Checks if the proposed position of the target tile overlaps with any other tile.
         * targetId is only used to exclude the tile being dragged from the check.
         */
        function checkCollision(targetId, newLeft, newTop) {
            const { width: targetW, height: targetH } = window.getCurrentTileDimensions();
            
            const targetRight = newLeft + targetW;
            const targetBottom = newTop + targetH;

            for (const [id, data] of allTiles.entries()) {
                if (id === targetId) continue; 
                
                const otherElement = document.getElementById(`tile-${id}`);
                if (!otherElement) continue;

                const otherW = otherElement.offsetWidth;
                const otherH = otherElement.offsetHeight;
                
                // Get position from the element's style property if available, otherwise fall back to data
                let otherLeft = parseFloat(otherElement.style.left);
                let otherTop = parseFloat(otherElement.style.top);
                
                if (isNaN(otherLeft) && data.left) otherLeft = parseFloat(data.left);
                if (isNaN(otherTop) && data.top) otherTop = parseFloat(data.top);

                if (isNaN(otherLeft) || isNaN(otherTop)) continue; 

                const overlapsX = newLeft < (otherLeft + otherW) && targetRight > otherLeft;
                const overlapsY = newTop < (otherTop + otherH) && targetBottom > otherTop;

                if (overlapsX && overlapsY) {
                    return true; 
                }
            }
            return false; 
        }

        /**
         * Finds the closest non-overlapping position near the center of the viewport.
         */
        function findSafeInitialPosition(tileWidth, tileHeight) {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;

            // Calculate exact center position
            let initialLeft = Math.round((viewportW / 2) - (tileWidth / 2));
            let initialTop = Math.round((viewportH / 2) - (tileHeight / 2));

            // Start simple non-overlapping check at center
            if (!checkCollision(null, initialLeft, initialTop)) {
                return { left: `${initialLeft}px`, top: `${initialTop}px` };
            }

            // Simple spiral search parameters
            const maxOffset = Math.max(viewportW, viewportH) / 3; // Search up to 1/3 of the screen size
            const step = 20; // 20px step distance

            let offset = step; // Start spiral at the first layer out

            // Spiral search pattern: 1R, 1U, 2L, 2D, 3R, 3U, 4L, 4D...
            while (offset <= maxOffset) {
                
                // 1. Right side check (x=offset, y runs -offset to offset)
                for (let y = -offset; y <= offset; y += step) {
                    let x = offset;
                    let checkLeft = initialLeft + x;
                    let checkTop = initialTop + y;
                    
                    if (checkLeft >= 0 && checkTop >= 0 && 
                        checkLeft + tileWidth <= viewportW && 
                        checkTop + tileHeight <= viewportH) {
                        if (!checkCollision(null, checkLeft, checkTop)) {
                            return { left: `${checkLeft}px`, top: `${checkTop}px` };
                        }
                    }
                }
                
                // 2. Left side check (x=-offset, y runs -offset to offset)
                for (let y = -offset; y <= offset; y += step) {
                    let x = -offset;
                    let checkLeft = initialLeft + x;
                    let checkTop = initialTop + y;
                    
                    if (checkLeft >= 0 && checkTop >= 0 && 
                        checkLeft + tileWidth <= viewportW && 
                        checkTop + tileHeight <= viewportH) {
                        if (!checkCollision(null, checkLeft, checkTop)) {
                            return { left: `${checkLeft}px`, top: `${checkTop}px` };
                        }
                    }
                }

                // 3. Top side check (y=-offset, x runs -offset+step to offset-step)
                for (let x = -offset + step; x < offset; x += step) {
                    let y = -offset;
                    let checkLeft = initialLeft + x;
                    let checkTop = initialTop + y;
                    
                    if (checkLeft >= 0 && checkTop >= 0 && 
                        checkLeft + tileWidth <= viewportW && 
                        checkTop + tileHeight <= viewportH) {
                        if (!checkCollision(null, checkLeft, checkTop)) {
                            return { left: `${checkLeft}px`, top: `${checkTop}px` };
                        }
                    }
                }
                
                // 4. Bottom side check (y=offset, x runs -offset+step to offset-step)
                for (let x = -offset + step; x < offset; x += step) {
                    let y = offset;
                    let checkLeft = initialLeft + x;
                    let checkTop = initialTop + y;
                    
                    if (checkLeft >= 0 && checkTop >= 0 && 
                        checkLeft + tileWidth <= viewportW && 
                        checkTop + tileHeight <= viewportH) {
                        if (!checkCollision(null, checkLeft, checkTop)) {
                            return { left: `${checkLeft}px`, top: `${checkTop}px` };
                        }
                    }
                }

                offset += step; // Expand the search radius
            }
            
            // Fallback: If no space is found after extensive searching, return the initial center position
            return { left: `${initialLeft}px`, top: `${initialTop}px` };
        }
        
        // --- UI Control ---
        
        function hideModal(modal) {
            modal.classList.add('hidden');
        }
        
        // --- Data Listener and Auth Setup ---

        function startDataListener() {
            if (!db) {
                console.warn("Cannot start data listener: Database not initialized.");
                return;
            }
            
            const sharedTilesColRef = collection(db, 'artifacts', appId, 'public', 'data', 'shared_tiles');
            
            // Set up real-time listener for the entire collection
            onSnapshot(query(sharedTilesColRef), (querySnapshot) => {
                let currentTiles = new Map();
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    currentTiles.set(doc.id, data);
                });
                
                allTiles = currentTiles;
                window.renderAllTiles();
                
                // Only show the creation modal if the user is authenticated and hasn't created a tile yet.
                if (authReady && userId && !allTiles.has(userId)) {
                    createPromptModal.classList.remove('hidden');
                } else {
                    hideModal(createPromptModal);
                }
                
            }, (error) => {
                console.error("Error listening to shared tiles:", error);
            });
        }
        
        /**
         * Initializes Firebase and starts Auth. Includes robust configuration check.
         */
        async function setupAuthAndData() {
            const createButton = document.getElementById('submit-button');
            
            try {
                if (!firebaseConfig.projectId || !firebaseConfig.apiKey) {
                    firebaseConfig = {
                        apiKey: manualApiKeyFallback,
                        authDomain: `${manualProjectIdFallback}.firebaseapp.com`,
                        projectId: manualProjectIdFallback,
                        storageBucket: `${manualProjectIdFallback}.appspot.com`,
                        messagingSenderId: "1234567890", 
                        appId: "1:1234567890:web:1234567890abcdef",
                    };
                    
                    let statusHtml = `Using manual configuration for Project ID and API Key.`;
                    
                    if (userStatusText) userStatusText.innerHTML = statusHtml;

                    if (!firebaseConfig.projectId || !firebaseConfig.apiKey) {
                        console.error("Firebase config is completely missing even with fallbacks. Cannot proceed.");
                        authReady = true; 
                        userId = null; 
                        hideModal(createPromptModal); 
                        if(createButton.checkInputStatus) createButton.checkInputStatus();
                        return;
                    }
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                if (userStatusText) userStatusText.textContent = "Status: Authenticating user...";
                
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authReady = true;
                        startDataListener(); 
                        if (userStatusText) userStatusText.innerHTML = `Signed In. ID: <span class="font-bold text-blue-600">${userId}</span>`;
                        if(createButton.checkInputStatus) createButton.checkInputStatus();
                    } else {
                        userId = null; 
                        authReady = true; 
                        console.warn("User signed out or auth failed.");
                        if (userStatusText) userStatusText.innerHTML = `<span class="text-red-600 font-bold">Error: Authentication Failed. Check Console.</span>`;
                        if(createButton.checkInputStatus) createButton.checkInputStatus();
                    }
                });
                
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth); 
                }

            } catch (error) {
                userId = null;
                authReady = true;
                console.error("FATAL: Error during Firebase initialization:", error);
                if (userStatusText) userStatusText.innerHTML = `<span class="text-red-600 font-bold">Error: Initialization Failed. Check Console.</span>`;
            }
        }
        
        // --- Drag Handlers ---
        
        function handleDragStart(e) {
            if (!userId) {
                 console.warn("Drag blocked: Cannot save state without active user ID.");
                 return;
            }

            const tileElement = e.currentTarget;
            const tileId = tileElement.dataset.tileId;
            const tileData = allTiles.get(tileId);

            if (tileData.creatorId !== userId || (tileData.movesMade >= MAX_DRAG_SESSIONS && tileData.moveRestrictionEndTime > Date.now())) {
                return;
            }
            
            // Block multi-touch gestures
            if (e.touches && e.touches.length > 1) {
                return;
            }

            e.preventDefault(); 
            isDragging = true;
            activeTileElement = tileElement; 
            activeTileId = tileId;
            
            activeTileElement.classList.add('active-drag-state');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = activeTileElement.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;
        }

        function handleDragMove(e) {
            if (!isDragging || !activeTileElement) return;
            // Prevent default touch scrolling/gestures
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let newLeft = clientX - offsetX;
            let newTop = clientY - offsetY;

            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const elementW = activeTileElement.offsetWidth;
            const elementH = activeTileElement.offsetHeight;
            
            // Boundary check: ensures tiles never leave the viewport 
            newLeft = Math.max(0, Math.min(newLeft, viewportW - elementW));
            newTop = Math.max(0, Math.min(newTop, viewportH - elementH));
            
            // Collision check
            if (checkCollision(activeTileId, newLeft, newTop)) {
                return; 
            }

            activeTileElement.style.left = `${newLeft}px`;
            activeTileElement.style.top = `${newTop}px`;
        }

        function handleDragEnd() {
            if (!isDragging || !activeTileId) return;
            
            const tileData = allTiles.get(activeTileId);
            
            if (activeTileElement) activeTileElement.classList.remove('active-drag-state');
            
            if (userId) {
                if (tileData.movesMade < MAX_DRAG_SESSIONS || tileData.moveRestrictionEndTime <= Date.now()) {
                    
                    const newMovesMade = (tileData.movesMade < MAX_DRAG_SESSIONS) ? tileData.movesMade + 1 : MAX_DRAG_SESSIONS;
                    let newRestrictionEndTime = tileData.moveRestrictionEndTime;
                    
                    if (newMovesMade >= MAX_DRAG_SESSIONS) {
                        newRestrictionEndTime = Date.now() + COOLDOWN_DURATION_MS; 
                    }

                    saveTile({
                        creatorId: activeTileId, 
                        movesMade: newMovesMade,
                        moveRestrictionEndTime: newRestrictionEndTime,
                        left: activeTileElement.style.left,
                        top: activeTileElement.style.top,
                    });
                }
            } else {
                 console.error("Drag end failed: Cannot save position. User unauthenticated.");
            }
            
            isDragging = false;
            activeTileElement = null; 
            activeTileId = null;
        }

        // Attach global drag listeners
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        // Use passive: false for touchmove to ensure preventDefault works
        document.addEventListener('touchmove', handleDragMove, { passive: false }); 
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);


        // --- Tile Rendering (Reverted to base64Image) ---
        
        window.renderSingleTile = function(tileId, tileData) {
            const domId = `tile-${tileId}`;
            let tileElement = document.getElementById(domId);
            let cooldownIntervalId = parseInt(tileElement?.dataset?.cooldownInterval || '0');

            if (!tileElement) {
                tileElement = document.createElement('div');
                tileElement.id = domId;
                tileElement.dataset.tileId = tileId;
                tileElement.classList.add('draggable-tile'); 
                canvasContainer.appendChild(tileElement);
            }
            
            const isMyTile = tileId === userId;
            let movesLeft = MAX_DRAG_SESSIONS - tileData.movesMade;
            const isCooldownExpired = tileData.moveRestrictionEndTime > 0 && Date.now() >= tileData.moveRestrictionEndTime;
            
            if (isCooldownExpired && isMyTile && userId) {
                saveTile({ movesMade: 0, moveRestrictionEndTime: 0 });
                movesLeft = MAX_DRAG_SESSIONS;
            }
            
            const isRestricted = isMyTile && tileData.movesMade >= MAX_DRAG_SESSIONS && tileData.moveRestrictionEndTime > Date.now();
            
            tileElement.className = `${TILE_BASE_CLASSES} ${TILE_SIZE_CLASSES}`; 

            if (tileData.base64Image) {
                tileElement.style.backgroundImage = `url('${tileData.base64Image}')`;
                tileElement.style.backgroundColor = '#d1d5db'; 
            } else {
                console.warn(`Rendering tile ${tileId}. Missing or undefined base64Image data.`);
                tileElement.style.backgroundImage = 'none';
                tileElement.style.backgroundColor = '#4B5563'; 
            }

            const textColor = 'text-white'; 
            
            let movesDisplayText = '';
            if (isMyTile) {
                 movesDisplayText = isRestricted ? 'COOLDOWN: initializing...' : `Moves Left: ${movesLeft}/${MAX_DRAG_SESSIONS}`;
            } else {
                 movesDisplayText = 'Shared Piece (Move limit does not apply to you)';
            }
            
            const infoTagContent = `
                <p class="font-bold mb-1 truncate text-lg">Name: ${tileData.name}</p>
                <p class="mb-1">Owner: ${isMyTile ? 'You' : tileData.name}</p>
                <p class="font-mono text-xs">${movesDisplayText}</p> 
                <p class="text-[8px] opacity-70 break-all mt-1">ID: ${tileId}</p>
            `;
            
            // Updated innerHTML to include the pushpins
            tileElement.innerHTML = `
                <!-- Pushpins for the four corners -->
                <div class="pushpin top-left"></div>
                <div class="pushpin top-right"></div>
                <div class="pushpin bottom-left"></div>
                <div class="pushpin bottom-right"></div>
            
                <div class="h-full w-full flex flex-col justify-end items-end p-2 select-none pointer-events-none">
                    <p class="text-xs italic font-normal ${textColor} opacity-80 select-none bg-black bg-opacity-40 px-2 py-1">
                        ${isMyTile ? 'Your Tile' : `Shared by ${tileData.name}`}
                    </p>
                </div>
                <!-- Hidden Info Tag -->
                <div id="info-tag-${tileId}" class="info-tag">
                    ${infoTagContent}
                </div>
                <!-- Toggle Button -->
                <button id="info-toggle-${tileId}" class="info-toggle-button">
                    +
                </button>
            `;
            
            // Attach toggle button listener
            const toggleButton = tileElement.querySelector(`#info-toggle-${tileId}`);
            const infoTag = tileElement.querySelector(`#info-tag-${tileId}`);
            
            if (toggleButton && infoTag) {
                const toggleInfo = () => {
                    infoTag.classList.toggle('visible');
                    toggleButton.textContent = infoTag.classList.contains('visible') ? 'x' : '+';
                };
                
                const stopPropagation = (e) => {
                    e.stopPropagation();
                }

                toggleButton.addEventListener('mousedown', stopPropagation);
                toggleButton.addEventListener('touchstart', stopPropagation, { passive: false });
                
                toggleButton.addEventListener('click', toggleInfo);
                toggleButton.addEventListener('touchend', (e) => {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    toggleInfo();
                });
            }

            // Dragging logic
            if (isMyTile && !isRestricted && userId) {
                tileElement.onmousedown = handleDragStart;
                tileElement.ontouchstart = handleDragStart;
                tileElement.style.cursor = 'grab';
                tileElement.classList.remove('opacity-50', 'shadow-inner', 'cursor-not-allowed');
            } else {
                tileElement.onmousedown = null;
                tileElement.ontouchstart = null;
                tileElement.style.cursor = 'default';
                tileElement.classList.remove('active-drag-state'); 

                if (isMyTile && isRestricted) {
                    tileElement.classList.add('opacity-50', 'cursor-not-allowed', 'shadow-inner');
                } else {
                    tileElement.classList.remove('opacity-50', 'shadow-inner', 'cursor-not-allowed');
                    tileElement.classList.add('opacity-90');
                }
            }
            
            // Cooldown Interval Logic (only runs if userId is available)
            if (userId && isMyTile && isRestricted) {
                if (cooldownIntervalId) clearInterval(cooldownIntervalId);
                
                const updateRestrictionDisplay = () => {
                    const now = Date.now();
                    const timeRemaining = tileData.moveRestrictionEndTime - now;
                    const movesDisplayElement = tileElement.querySelector('.info-tag p:nth-child(3)'); 

                    if (timeRemaining <= 0) {
                        clearInterval(parseInt(tileElement.dataset.cooldownInterval));
                        saveTile({ movesMade: 0, moveRestrictionEndTime: 0 }); 
                        return; 
                    }

                    const secondsTotal = Math.ceil(timeRemaining / 1000);
                    const minutes = Math.floor(secondsTotal / 60);
                    const seconds = secondsTotal % 60;
                    const displayTime = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    
                    if(movesDisplayElement) movesDisplayElement.textContent = `COOLDOWN: ${displayTime}`;
                };
                
                updateRestrictionDisplay(); 
                const newIntervalId = setInterval(updateRestrictionDisplay, 1000);
                tileElement.dataset.cooldownInterval = newIntervalId;
            } else if (cooldownIntervalId) {
                 clearInterval(cooldownIntervalId);
                 tileElement.dataset.cooldownInterval = '0';
            }
            
            // Set position 
            const isCurrentlyDragged = activeTileId === tileId && isDragging;
            
            if(!isCurrentlyDragged && tileData.left && tileData.top) {
                tileElement.style.left = tileData.left; 
                tileElement.style.top = tileData.top; 
            }
        }

        window.renderAllTiles = function() {
            const existingTileIds = new Set();
            canvasContainer.querySelectorAll('.draggable-tile').forEach(el => {
                existingTileIds.add(el.dataset.tileId);
            });
            
            for (const [id, data] of allTiles.entries()) {
                window.renderSingleTile(id, data);
                existingTileIds.delete(id); 
            }
            
            existingTileIds.forEach(idToRemove => {
                const element = document.getElementById(`tile-${idToRemove}`);
                if (element) {
                    const intervalId = parseInt(element.dataset.cooldownInterval || '0');
                    if(intervalId) clearInterval(intervalId);
                    element.remove();
                }
            });
        }


        // --- Event Binding for Modals ---
        
        function setupPromptHandlers() {
            const createNameInput = document.getElementById('name-input');
            const imageUploadInput = document.getElementById('image-upload'); 
            const imagePreviewElement = document.getElementById('image-preview');
            const createButton = document.getElementById('submit-button');
            const compressionStatus = document.getElementById('compression-status');
            
            const checkCreateInput = () => {
                const nameValid = createNameInput.value.trim().length > 0;
                const imageValid = uploadedBase64Image !== null; 
                
                createButton.disabled = !(nameValid && imageValid && authReady && userId);
            };

            createButton.checkInputStatus = checkCreateInput;

            // Image file reader with compression
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                
                if (!file) {
                    uploadedBase64Image = null;
                    imagePreviewElement.style.backgroundImage = 'none';
                    imagePreviewElement.textContent = 'Preview';
                    compressionStatus.classList.add('hidden');
                    checkCreateInput();
                    return;
                }
                
                uploadedBase64Image = null; // Disable button while processing
                checkCreateInput();
                
                imagePreviewElement.textContent = 'Compressing...';
                imagePreviewElement.classList.remove('bg-gray-100');
                imagePreviewElement.classList.add('bg-yellow-100');
                compressionStatus.classList.remove('hidden');
                
                try {
                    const compressedDataUrl = await resizeAndCompressImage(file);
                    uploadedBase64Image = compressedDataUrl;
                    
                    // Show final compressed data size for debugging/confirmation
                    const sizeKB = Math.round(compressedDataUrl.length / 1024);
                    compressionStatus.textContent = `Compressed: ${sizeKB} KB (Safe for Firestore)`;
                    
                    imagePreviewElement.style.backgroundImage = `url('${compressedDataUrl}')`;
                    imagePreviewElement.textContent = '';
                    
                } catch (error) {
                    console.error("Error processing image:", error);
                    uploadedBase64Image = null;
                    imagePreviewElement.style.backgroundImage = 'none';
                    imagePreviewElement.textContent = 'Error';
                    compressionStatus.textContent = 'Error compressing image!';
                }
                
                imagePreviewElement.classList.add('bg-gray-100');
                imagePreviewElement.classList.remove('bg-yellow-100');
                checkCreateInput(); 
            });

            createNameInput.addEventListener('keyup', checkCreateInput); 
            createNameInput.addEventListener('input', checkCreateInput); 
            
            checkCreateInput(); 


            const createNewTile = async () => {
                const name = createNameInput.value.trim();
                
                if (!name || !uploadedBase64Image || !userId) {
                    console.error("Cannot create tile: Critical data missing (User ID, Name, or Image).");
                    checkCreateInput();
                    return;
                }

                console.log(`Attempting to create and save tile for user: ${userId}`);

                hideModal(createPromptModal);
                
                const creationDate = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                // Get safe, non-overlapping initial position
                const { width, height } = window.getCurrentTileDimensions(); 
                const { left: initialLeft, top: initialTop } = findSafeInitialPosition(width, height);
                
                const newTileData = {
                    creatorId: userId, 
                    name: name,
                    base64Image: uploadedBase64Image, 
                    left: initialLeft,
                    top: initialTop,
                    createdAt: creationDate,
                    movesMade: 0, 
                    moveRestrictionEndTime: 0,
                };
                
                await saveTile(newTileData); 
            };

            // Event Listeners for the button
            createButton.addEventListener('click', createNewTile);
            createButton.addEventListener('touchend', (e) => { e.preventDefault(); createNewTile(); });
            createNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !createButton.disabled) createNewTile();
            });
        }


        // --- Core Execution Flow ---
        
        setupPromptHandlers();
        setupAuthAndData();
        
    </script>
</body>
</html>
