<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Tile Local Test</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f3f6;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll when tile is near edge */
        }
        .centered-input-view {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .draggable-tile {
            position: absolute;
            user-select: none;
            cursor: grab;
            transition: box-shadow 0.3s ease;
        }
        .draggable-tile:active {
            cursor: grabbing;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); /* Larger shadow when grabbing */
        }
        /* Style for the User ID display (now removed from HTML) */
    </style>
</head>
<body>
    
    <!-- Removed Firebase Initialization Script to enable instant loading -->
    
    <!-- Main container for the draggable element -->
    <section id="canvas-container" class="absolute inset-0 w-full h-full">
        <!-- Removed User ID display element -->
        <!-- Tile or Input Prompt Renders here -->
    </section>

    <script>
        // --- Global State ---
        const canvasContainer = document.getElementById('canvas-container');
        let localTileData = null; // Stores the single, non-persistent tile data locally.
        const MAX_DRAG_SESSIONS = 6; // <-- Limit to 6 moves (drag sessions)
        const COOLDOWN_DURATION_MS = 60000; // 1 minute cooldown
        let cooldownIntervalId = null; // ID to manage the countdown timer
        
        // Generate a local, anonymous user ID instantly (no authentication required)
        const currentUserId = crypto.randomUUID();

        const COLORS = {
            'Red': 'bg-red-500',
            'Orange': 'bg-orange-500',
            'Yellow': 'bg-yellow-400',
            'Green': 'bg-green-500',
            'Blue': 'bg-blue-600',
            'Indigo': 'bg-indigo-600',
            'Violet': 'bg-purple-600',
            'Black': 'bg-black'
        };
        let selectedColor = COLORS['Red'];
        
        // --- Drag State Variables ---
        let isDragging = false;
        let activeTileElement = null;
        let offsetX = 0;
        let offsetY = 0;
        
        // Tile dimensions (for bounds checking)
        const TILE_SIZE_SM = 192; // w-48
        const TILE_SIZE_LG = 224; // sm:w-56 

        /**
         * Returns the correct tile size based on the current viewport.
         */
        function getCurrentTileSize() {
            return window.innerWidth >= 640 ? TILE_SIZE_LG : TILE_SIZE_SM;
        }
        
        // --- Drag Handlers ---

        function handleDragStart(e) {
            // Check if the move limit has been reached AND if the cooldown is active
            if (localTileData && localTileData.movesMade >= MAX_DRAG_SESSIONS && localTileData.moveRestrictionEndTime > Date.now()) {
                return;
            }

            // Only start drag if it's the element itself
            if (e.target.id !== 'my-tile') return;

            e.preventDefault(); 
            isDragging = true;
            activeTileElement = e.currentTarget; 
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = activeTileElement.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;
        }

        function handleDragMove(e) {
            if (!isDragging || !activeTileElement) return;
            
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let newLeft = clientX - offsetX;
            let newTop = clientY - offsetY;

            // --- BOUNDARY CONSTRAINT LOGIC ---
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const elementW = activeTileElement.offsetWidth;
            const elementH = activeTileElement.offsetHeight;

            // Clamp positions to stay within bounds
            newLeft = Math.max(0, Math.min(newLeft, viewportW - elementW));
            newTop = Math.max(0, Math.min(newTop, viewportH - elementH));
            // --- END BOUNDARY LOGIC ---

            // Apply the constrained position
            activeTileElement.style.left = `${newLeft}px`;
            activeTileElement.style.top = `${newTop}px`;
            
            // Update local state (for use if we re-render or resize)
            localTileData.left = activeTileElement.style.left;
            localTileData.top = activeTileElement.style.top;
        }

        /**
         * Called when a drag session ends successfully.
         * Increments the move counter and triggers a re-render.
         */
        function finalizeMove() {
            if (!localTileData) return;
            
            // Check if limit is already reached and cooldown is active
            if (localTileData.movesMade >= MAX_DRAG_SESSIONS && localTileData.moveRestrictionEndTime > Date.now()) {
                return;
            }
            
            // Increment the move count
            localTileData.movesMade += 1;
            
            // If this move *hits* the limit, set the cooldown time
            if (localTileData.movesMade >= MAX_DRAG_SESSIONS) {
                // Set cooldown for 60 seconds (1 minute)
                localTileData.moveRestrictionEndTime = Date.now() + COOLDOWN_DURATION_MS; 
            }

            console.log(`Move completed. Moves made: ${localTileData.movesMade}`);
            
            // Re-render to update the moves count display and check for restrictions
            renderTile(); 
        }

        function handleDragEnd() {
            if (!isDragging) return;
            
            // Only finalize move if we had an active tile element (i.e., a drag session occurred)
            if (activeTileElement) {
                finalizeMove();
            }
            
            isDragging = false;
            activeTileElement = null; 
        }

        // Attach global document listeners for drag movement/end 
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchmove', handleDragMove, { passive: false }); 
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);

        // --- Core Functions ---

        /**
         * Renders the single tile DOM element based on localTileData.
         */
        function renderTile() {
            // 1. Clear previous interval (always do this first in render)
            if (cooldownIntervalId) {
                clearInterval(cooldownIntervalId);
                cooldownIntervalId = null;
            }

            // Remove prompt if it exists
            const inputPrompt = document.getElementById('input-prompt');
            if(inputPrompt) {
                inputPrompt.remove();
                canvasContainer.className = 'absolute inset-0 w-full h-full';
            }

            if (!localTileData) return;
            
            const tileData = localTileData;
            const domId = 'my-tile';
            let tileElement = document.getElementById(domId);

            if (!tileElement) {
                tileElement = document.createElement('div');
                tileElement.id = domId;
                tileElement.classList.add('draggable-tile'); 
                canvasContainer.appendChild(tileElement);
            }
            
            // --- MOVES LEFT & COOLDOWN LOGIC ---
            let movesLeft = MAX_DRAG_SESSIONS - tileData.movesMade;
            
            // Check if cooldown is over AND we were in the restricted state
            const isCooldownExpired = tileData.moveRestrictionEndTime > 0 && Date.now() >= tileData.moveRestrictionEndTime;
            
            if (isCooldownExpired) {
                // Reset state to allow moves again
                tileData.movesMade = 0;
                tileData.moveRestrictionEndTime = 0; 
                movesLeft = MAX_DRAG_SESSIONS; // Update display variable immediately
            }
            
            // Determine current restriction status
            const isRestricted = tileData.movesMade >= MAX_DRAG_SESSIONS && tileData.moveRestrictionEndTime > Date.now();

            // Determine initial display text
            let movesDisplayText = isRestricted 
                ? 'COOLDOWN: initializing...' // Placeholder
                : `Moves Left: ${movesLeft} of ${MAX_DRAG_SESSIONS}`;
            // --- END MOVES LEFT & COOLDOWN LOGIC ---

            // Apply styling classes
            const colorClass = tileData.color;

            tileElement.className = `w-48 h-48 sm:w-56 sm:h-56 shadow-xl rounded-lg ${colorClass}`;
            tileElement.classList.add('draggable-tile'); // Re-add after clearing className

            // Determine text color for contrast
            const isLightColor = colorClass.includes('yellow') || colorClass.includes('400');
            const textColor = isLightColor ? 'text-gray-800' : 'text-white';
            
            // Set the contents 
            tileElement.innerHTML = `
                <div id="my-tile" class="h-full w-full flex flex-col justify-center items-center p-4">
                    <h2 class="text-3xl font-extrabold tracking-tight ${textColor} text-center select-none pointer-events-none">
                        ${tileData.name}
                    </h2>
                    <p class="text-sm italic font-normal ${textColor} opacity-80 mt-2 select-none pointer-events-none">
                        Created: ${tileData.createdAt}
                    </p>
                    <p class="text-xs font-mono text-center mt-2 font-bold ${textColor} opacity-100 pointer-events-none" id="moves-display-text">
                        ${movesDisplayText}
                    </p>
                    <p class="text-xs font-mono text-center mt-1 ${textColor} opacity-60 pointer-events-none">
                        ID: ${currentUserId.substring(0, 8) + '...'}
                    </p>
                </div>
            `;
            
            // 3. Set up dynamic display and interval if restricted
            if (isRestricted) {
                const movesDisplayElement = tileElement.querySelector('#moves-display-text');

                const updateRestrictionDisplay = () => {
                    const now = Date.now();
                    const timeRemaining = tileData.moveRestrictionEndTime - now;

                    if (timeRemaining <= 0) {
                        clearInterval(cooldownIntervalId);
                        cooldownIntervalId = null;
                        // Cooldown finished, re-render to reset state and re-enable tile
                        renderTile();
                        return;
                    }

                    // Calculate minutes and seconds (rounding up to the nearest second)
                    const secondsTotal = Math.ceil(timeRemaining / 1000);
                    const minutes = Math.floor(secondsTotal / 60);
                    const seconds = secondsTotal % 60;
                    
                    const displayTime = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    
                    if(movesDisplayElement) {
                        movesDisplayElement.textContent = `COOLDOWN: ${displayTime}`;
                    }
                };
                
                // Initial update and start interval
                updateRestrictionDisplay(); 
                cooldownIntervalId = setInterval(updateRestrictionDisplay, 1000);
                
                // Disable handlers and apply visual cues
                tileElement.onmousedown = null;
                tileElement.ontouchstart = null;
                tileElement.style.cursor = 'default';
                tileElement.classList.add('opacity-75', 'cursor-not-allowed'); 
                tileElement.classList.remove('grayscale');

            } else {
                // Ensure handlers are active
                tileElement.onmousedown = handleDragStart;
                tileElement.ontouchstart = handleDragStart;
                tileElement.style.cursor = 'grab';
                tileElement.classList.remove('grayscale', 'opacity-75', 'cursor-not-allowed');
            }

            // Apply position
            tileElement.style.left = tileData.left; 
            tileElement.style.top = tileData.top; 
        }

        /**
         * Renders the name and color input prompt screen.
         */
        function renderInputPrompt() {
            // Don't render if a tile already exists
            if (localTileData) return;
            
            // Clear canvas and set to centered view
            canvasContainer.innerHTML = '';
            canvasContainer.className = 'w-full centered-input-view';
            
            const promptDiv = document.createElement('div');
            promptDiv.id = 'input-prompt';
            promptDiv.className = 'w-full max-w-xs mx-4 p-6 bg-white shadow-xl rounded-xl';

            // Generate color swatch HTML
            const colorSwatches = Object.entries(COLORS).map(([name, colorClass]) => `
                <button type="button" data-color="${colorClass}" 
                    class="color-swatch w-7 h-7 rounded-full shadow-md hover:ring-4 hover:ring-offset-2 hover:ring-gray-300 ${colorClass} transition duration-150 ease-in-out" 
                    title="${name}"
                ></button>
            `).join('');

            promptDiv.innerHTML = `
                <div class="space-y-4">
                    <p class="text-xl font-bold text-gray-800 text-center">Create Your Tile</p>

                    <input
                        type="text"
                        id="name-input"
                        placeholder="Enter your name or greeting"
                        class="w-full px-3 py-2 border border-gray-400 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                        autocomplete="off"
                        autofocus
                        maxlength="15"
                    >
                    
                    <div class="flex flex-col space-y-2">
                        <p class="text-sm font-medium text-gray-600 text-center">Choose a Color</p>
                        <div id="color-picker" class="flex justify-between items-center px-2">
                            ${colorSwatches}
                        </div>
                    </div>

                    <button
                        id="submit-button"
                        class="w-full bg-blue-600 text-white py-2 rounded-lg font-medium hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-md"
                        disabled
                    >
                        Create Tile
                    </button>
                </div>
            `;
            canvasContainer.appendChild(promptDiv);

            const input = document.getElementById('name-input');
            const button = document.getElementById('submit-button');
            const colorPicker = document.getElementById('color-picker');

            const applyRing = (colorClass) => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('ring-gray-900', 'ring-2'));
                const currentSwatch = document.querySelector(`[data-color="${colorClass}"]`);
                if (currentSwatch) {
                    currentSwatch.classList.add('ring-gray-900', 'ring-2');
                }
            };
            
            applyRing(selectedColor);

            colorPicker.addEventListener('click', (e) => {
                const swatch = e.target.closest('.color-swatch');
                if (swatch) {
                    selectedColor = swatch.dataset.color;
                    applyRing(selectedColor);
                }
            });

            input.addEventListener('input', () => {
                const name = input.value.trim();
                button.disabled = name.length === 0;
            });

            const createNewTile = () => {
                const name = input.value.trim();
                if (!name || name.length === 0) return;

                const creationDate = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                // Calculate Initial Centered Pixel Position
                const size = getCurrentTileSize();
                const initialLeft = `${(window.innerWidth / 2) - (size / 2)}px`;
                const initialTop = `${(window.innerHeight / 2) - (size / 2)}px`;
                
                localTileData = {
                    name: name,
                    color: selectedColor,
                    left: initialLeft,
                    top: initialTop,
                    createdAt: creationDate,
                    userId: currentUserId, // Use the locally generated ID
                    movesMade: 0, 
                    moveRestrictionEndTime: 0, // <-- New state for cooldown end time
                };

                // Render the tile and hide the prompt
                renderTile();
            };

            button.addEventListener('click', createNewTile);
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !button.disabled) {
                    createNewTile();
                }
            });
            input.focus();
        }

        // Start the application immediately since there is no Firebase Auth step
        renderInputPrompt();

        // Re-render on resize to maintain correct drag behavior
        window.addEventListener('resize', renderTile); 
    </script>
</body>
</html>
