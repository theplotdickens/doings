<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Collaborative Greeter</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the Inter font and main centering */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f3f6;
            min-height: 100vh;
            margin: 0;
            transition: background-color 0.5s;
        }
        /* Style for the initial input screen centering (ensures full height mobile support) */
        .centered-input-view {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* Custom class to ensure cursor changes work correctly */
        .draggable-tile {
            position: absolute; /* Enforce absolute positioning */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }
        .draggable-tile.is-owner {
            border: 4px solid #3b82f6; /* Highlight for the owner's tile */
        }
        .draggable-tile.is-owner .tile-content {
            cursor: grab;
        }
    </style>
</head>
<body>
    
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase Log Level to Debug for development/debugging
        setLogLevel('Debug');

        // Global variables provided by the canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const app = initializeApp(firebaseConfig);
        window.db = getFirestore(app);
        window.auth = getAuth(app);
        window.currentUserId = null;
        window.isAuthReady = false;

        // Public collection path for shared tiles: /artifacts/{appId}/public/data/tiles
        window.TILE_COLLECTION_PATH = `/artifacts/${appId}/public/data/tiles`;

        // 1. Handle Authentication
        onAuthStateChanged(window.auth, async (user) => {
            if (user) {
                window.currentUserId = user.uid;
            } else {
                // Sign in anonymously if no token or token sign-in failed
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(window.auth, initialAuthToken);
                        window.currentUserId = window.auth.currentUser.uid;
                    } else {
                        await signInAnonymously(window.auth);
                        window.currentUserId = window.auth.currentUser.uid;
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                    window.currentUserId = crypto.randomUUID(); // Fallback to a random ID
                }
            }
            window.isAuthReady = true;
            window.initializeApp();
        });

        // Expose necessary Firestore/Auth methods to the global scope for use in the non-module script
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;
        window.collection = collection;
        window.query = query;
        window.signInAnonymously = signInAnonymously;
    </script>
    
    <!-- Main container for all draggable elements -->
    <section id="canvas-container" class="absolute inset-0 w-full h-full">
        <div class="absolute top-2 left-2 p-2 bg-white rounded-lg shadow-md text-xs text-gray-600">
            User ID: <span id="user-id-display">Loading...</span>
        </div>
        <!-- Draggable content will be rendered here by JavaScript -->
    </section>

    <script>
        // --- Global Constants and State Keys ---
        const canvasContainer = document.getElementById('canvas-container');
        
        // Old keys (used only for cleanup/migration check)
        const LOCAL_STORAGE_TILE_KEY = 'userTiles';

        // Define colors (ROYGBIV + Black) and their corresponding Tailwind classes
        const COLORS = {
            'Red': 'bg-red-500',
            'Orange': 'bg-orange-500',
            'Yellow': 'bg-yellow-400',
            'Green': 'bg-green-500',
            'Blue': 'bg-blue-600',
            'Indigo': 'bg-indigo-600',
            'Violet': 'bg-purple-600',
            'Black': 'bg-black'
        };
        let selectedColor = COLORS['Red']; // Default color is Red
        
        // --- Real-time Data Store ---
        let tiles = []; // Holds ALL tiles fetched from Firestore
        let userTileExists = false; // Flag for rendering the input prompt
        
        // --- Drag State Variables ---
        let isDragging = false;
        let activeTileElement = null; // The DOM element being dragged
        let activeTileData = null; // The data object of the tile being dragged
        let offsetX = 0;
        let offsetY = 0;
        
        // Tile dimensions (must match CSS classes: w-48 h-48 or sm:w-56 sm:h-56)
        const TILE_SIZE_SM = 192; 
        const TILE_SIZE_LG = 224; 

        /**
         * Returns the correct tile size based on the current viewport.
         */
        function getCurrentTileSize() {
            // Check if we are past the Tailwind 'sm' breakpoint (640px)
            return window.innerWidth >= 640 ? TILE_SIZE_LG : TILE_SIZE_SM;
        }
        
        /**
         * Saves or updates a tile document in Firestore.
         */
        async function saveTileToFirestore(tileData) {
            if (!window.db || !window.currentUserId) {
                console.warn("Database or User ID not ready.");
                return;
            }
            try {
                // Use the userId as the document ID for the tile
                const tileRef = window.doc(window.db, window.TILE_COLLECTION_PATH, tileData.userId);
                
                await window.setDoc(tileRef, {
                    userId: tileData.userId,
                    name: tileData.name,
                    color: tileData.color,
                    left: tileData.left,
                    top: tileData.top,
                    createdAt: tileData.createdAt 
                }, { merge: true });
                
                console.log("Tile saved successfully for user:", tileData.userId);
            } catch (e) {
                console.error("Error writing document:", e);
            }
        }

        /**
         * Sets up the real-time listener for all tiles in the collection.
         */
        function setupRealtimeListener() {
            if (!window.db || !window.isAuthReady) {
                console.warn("Cannot start listener: Auth not ready.");
                return;
            }
            
            document.getElementById('user-id-display').textContent = window.currentUserId;

            const collectionRef = window.collection(window.db, window.TILE_COLLECTION_PATH);
            const q = window.query(collectionRef);

            // Listen for real-time updates
            window.onSnapshot(q, (snapshot) => {
                const newTiles = [];
                userTileExists = false;

                snapshot.forEach((doc) => {
                    const tileData = doc.data();
                    if (tileData.userId === window.currentUserId) {
                        userTileExists = true; // Mark that the user has created a tile
                    }
                    newTiles.push(tileData);
                });

                tiles = newTiles;
                renderTiles();
            }, (error) => {
                console.error("Firestore real-time error:", error);
                // Fallback to showing input if error occurs and no tiles are loaded
                if (tiles.length === 0) {
                     renderInputPrompt();
                }
            });
        }

        // --- Drag Handlers ---

        /**
         * Starts the dragging process on mousedown or touchstart.
         */
        function handleDragStart(e) {
            const tileElement = e.currentTarget;
            
            // Check if the tile belongs to the current user
            if (!tileElement.classList.contains('is-owner') || e.target.tagName === 'BUTTON') return;
            
            e.preventDefault(); 
            isDragging = true;
            activeTileElement = tileElement; 
            
            // Find the data object of the active tile
            activeTileData = tiles.find(t => t.userId === window.currentUserId);
            
            if (!activeTileData) return;
            
            // Get initial cursor/touch coordinates
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Calculate offset (point of click relative to element top-left)
            const rect = tileElement.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;

            tileElement.style.cursor = 'grabbing';
        }

        /**
         * Moves the element based on cursor/touch position and enforces boundary limits.
         */
        function handleDragMove(e) {
            if (!isDragging || !activeTileElement) return;
            
            // Prevent scrolling on touch devices while dragging the element
            e.preventDefault();

            // Get current cursor/touch coordinates
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Calculate potential new position
            let newLeft = clientX - offsetX;
            let newTop = clientY - offsetY;

            // --- Boundary Constraint Logic ---
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const elementW = activeTileElement.offsetWidth;
            const elementH = activeTileElement.offsetHeight;

            // Constrain Left and Right
            newLeft = Math.max(0, Math.min(newLeft, viewportW - elementW));
            // Constrain Top and Bottom
            newTop = Math.max(0, Math.min(newTop, viewportH - elementH));
            // --- End Boundary Logic ---

            // Apply the final, constrained position
            activeTileElement.style.left = `${newLeft}px`;
            activeTileElement.style.top = `${newTop}px`;
        }

        /**
         * Ends the dragging process and saves the final position to Firestore.
         */
        function handleDragEnd() {
            if (!isDragging || !activeTileElement || !activeTileData) return;
            isDragging = false;
            activeTileElement.style.cursor = 'grab';
            
            // Update position in the data object
            activeTileData.left = activeTileElement.style.left;
            activeTileData.top = activeTileElement.style.top;

            // Save the updated position to Firestore
            saveTileToFirestore(activeTileData);
            
            activeTileElement = null; 
            activeTileData = null;
        }

        // Attach global document listeners for drag movement/end (needed in case the mouse/finger leaves the element)
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        // Passive false is crucial for handleDragMove's e.preventDefault() to work on touch devices
        document.addEventListener('touchmove', handleDragMove, { passive: false }); 
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);

        // --- Core Functions ---

        /**
         * Renders a single tile DOM element.
         */
        function renderTile(tileData) {
            // Use userId as the unique DOM ID
            const domId = `tile-${tileData.userId}`;
            let tileElement = document.getElementById(domId);
            
            const isOwner = tileData.userId === window.currentUserId;

            if (!tileElement) {
                tileElement = document.createElement('div');
                tileElement.id = domId;
                tileElement.classList.add('draggable-tile'); // Add fixed class for absolute positioning
                canvasContainer.appendChild(tileElement);
            }

            // Apply size, color, and owner classes
            const colorClass = tileData.color;
            const cursorClass = isOwner ? 'cursor-grab' : 'cursor-default';
            const ownerClass = isOwner ? 'is-owner' : '';

            tileElement.className = `w-48 h-48 sm:w-56 sm:h-56 shadow-xl rounded-lg transition-shadow duration-300 ${cursorClass} hover:shadow-2xl ${colorClass} ${ownerClass}`;
            tileElement.classList.add('draggable-tile'); // Re-add after clearing className

            // Determine text color for contrast
            const isLightColor = colorClass.includes('yellow') || colorClass.includes('400');
            const textColor = isLightColor ? 'text-gray-800' : 'text-white';

            // Set the contents 
            tileElement.innerHTML = `
                <div class="tile-content h-full w-full flex flex-col justify-center items-center p-4">
                    <h2 class="text-3xl font-extrabold tracking-tight ${textColor} text-center select-none pointer-events-none">
                        ${tileData.name}
                    </h2>
                    <p class="text-sm italic font-normal ${textColor} opacity-80 mt-1 select-none pointer-events-none">
                        created ${tileData.createdAt}
                    </p>
                    <p class="text-xs font-mono text-center mt-2 ${textColor} opacity-60 pointer-events-none">
                        ${tileData.userId.substring(0, 8)}...
                    </p>
                </div>
            `;
            
            // Apply position (guaranteed to be pixel values)
            tileElement.style.left = tileData.left || '0px'; 
            tileElement.style.top = tileData.top || '0px'; 
            // Ensure no transform is applied as we are using absolute pixel positioning
            tileElement.style.transform = 'none'; 


            // Attach drag listeners only if the user is the owner
            if (isOwner) {
                tileElement.onmousedown = handleDragStart;
                tileElement.ontouchstart = handleDragStart;
            } else {
                // Remove listeners if they exist and it's not the owner
                tileElement.onmousedown = null;
                tileElement.ontouchstart = null;
            }
        }

        /**
         * Renders all tiles from the Firestore array.
         */
        function renderTiles() {
            // Remove the input prompt if it exists
            const inputPrompt = document.getElementById('input-prompt');
            if(inputPrompt) {
                inputPrompt.remove();
                canvasContainer.className = 'absolute inset-0 w-full h-full';
            }

            // Get IDs of tiles currently on screen
            const currentTileIds = Array.from(canvasContainer.querySelectorAll('.draggable-tile')).map(el => el.id);

            // Render/Update existing tiles
            const latestTileIds = new Set();
            tiles.forEach(tile => {
                renderTile(tile);
                latestTileIds.add(`tile-${tile.userId}`);
            });

            // Remove tiles that no longer exist in the data (e.g., deleted by another user)
            currentTileIds.forEach(domId => {
                if (!latestTileIds.has(domId)) {
                    const el = document.getElementById(domId);
                    if (el) el.remove();
                }
            });

            // If the current user hasn't created a tile, show the input prompt
            if (!userTileExists) {
                renderInputPrompt();
            }
        }

        /**
         * Renders the name and color input prompt screen.
         */
        function renderInputPrompt() {
            // Don't render if it already exists or if user tile already exists
            if (document.getElementById('input-prompt') || userTileExists) return;

            // Clear canvas and set to centered view
            canvasContainer.innerHTML = '';
            canvasContainer.className = 'w-full centered-input-view';
            
            const promptDiv = document.createElement('div');
            promptDiv.id = 'input-prompt';
            promptDiv.className = 'w-full max-w-xs mx-4 p-5 bg-white shadow-lg rounded-lg';

            // Generate color swatch HTML
            const colorSwatches = Object.entries(COLORS).map(([name, colorClass]) => `
                <button type="button" data-color="${colorClass}" 
                    class="color-swatch w-7 h-7 rounded-full shadow-md hover:ring-4 hover:ring-offset-2 hover:ring-gray-300 ${colorClass} transition duration-150 ease-in-out" 
                    title="${name}"
                ></button>
            `).join('');

            promptDiv.innerHTML = `
                <div class="space-y-4">
                    <p class="text-xl font-medium text-gray-800 text-center">Your Neat Tile</p>

                    <input
                        type="text"
                        id="name-input"
                        placeholder="Your name"
                        class="w-full px-3 py-2 border border-gray-400 rounded-md focus:ring-0 focus:border-gray-600 transition"
                        autocomplete="off"
                        autofocus
                    >
                    
                    <div class="flex flex-col space-y-2">
                        <p class="text-sm font-medium text-gray-600 text-center">Color Picker</p>
                        <div id="color-picker" class="flex justify-between items-center">
                            ${colorSwatches}
                        </div>
                    </div>

                    <button
                        id="submit-button"
                        class="w-full bg-gray-700 text-white py-2 rounded-md font-medium hover:bg-gray-800 transition disabled:opacity-50"
                    >
                        Create Tile
                    </button>
                </div>
            `;
            canvasContainer.appendChild(promptDiv);

            const input = document.getElementById('name-input');
            const button = document.getElementById('submit-button');
            const colorPicker = document.getElementById('color-picker');

            // Function to apply the selection ring
            const applyRing = (colorClass) => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('ring-gray-900', 'ring-2'));
                const currentSwatch = document.querySelector(`[data-color="${colorClass}"]`);
                if (currentSwatch) {
                    currentSwatch.classList.add('ring-gray-900', 'ring-2');
                }
            };
            
            applyRing(selectedColor);

            // Color picker logic
            colorPicker.addEventListener('click', (e) => {
                const swatch = e.target.closest('.color-swatch');
                if (swatch) {
                    selectedColor = swatch.dataset.color;
                    applyRing(selectedColor);
                }
            });

            const saveNewTile = () => {
                const name = input.value.trim();
                if (name && window.currentUserId) {
                    const creationDate = new Date().toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    
                    // --- Calculate Initial Centered Pixel Position ---
                    // Calculate based on current window size to avoid 50%/translate conflicts during dragging
                    const size = getCurrentTileSize();
                    const initialLeft = `${(window.innerWidth / 2) - (size / 2)}px`;
                    const initialTop = `${(window.innerHeight / 2) - (size / 2)}px`;
                    // --------------------------------------------------------

                    const newTileData = {
                        userId: window.currentUserId,
                        name: name,
                        color: selectedColor,
                        left: initialLeft, // Set initial pixel position
                        top: initialTop,    // Set initial pixel position
                        createdAt: creationDate 
                    };

                    // --- OPTIMISTIC UPDATE: Add the tile locally and rerender immediately ---
                    // This prevents the screen from going blank while waiting for the Firestore round trip.
                    tiles.push(newTileData); 
                    userTileExists = true;
                    renderTiles();
                    // -------------------------------------------------------------------------

                    // Save the new tile to Firestore
                    saveTileToFirestore(newTileData);
                }
            };

            button.addEventListener('click', saveNewTile);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveNewTile();
                }
            });

            input.focus();
        }

        /**
         * Cleans up old localStorage data (if any was left from previous versions).
         */
        function cleanupLocalStorage() {
            localStorage.removeItem(LOCAL_STORAGE_TILE_KEY);
            console.log("Cleaned up old local storage data.");
        }

        /**
         * Initializes the application state on load after Firebase is ready.
         */
        window.initializeApp = function() {
            // 1. Cleanup old local data
            cleanupLocalStorage();
            
            // 2. Start listening to the shared tile collection
            setupRealtimeListener();
        };

        // Rerender on resize to recalculate constraints (This is mainly to fix the boundary logic)
        window.addEventListener('resize', renderTiles);
    </script>
</body>
</html>
