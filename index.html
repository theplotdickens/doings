<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Tile Local Test</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f3f6;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll when tile is near edge */
        }
        .centered-input-view {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .draggable-tile {
            position: absolute;
            user-select: none;
            cursor: grab;
            transition: box-shadow 0.3s ease;
        }
        .draggable-tile:active {
            cursor: grabbing;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); /* Larger shadow when grabbing */
        }
    </style>
</head>
<body>
    
    <!-- Main container for the draggable element -->
    <section id="canvas-container" class="absolute inset-0 w-full h-full">
        <!-- Tile or Input Prompt Renders here -->
    </section>

    <script>
        // --- Global State ---
        const canvasContainer = document.getElementById('canvas-container');
        let localTileData = null; // Stores the single, non-persistent tile data locally.
        
        const COLORS = {
            'Red': 'bg-red-500',
            'Orange': 'bg-orange-500',
            'Yellow': 'bg-yellow-400',
            'Green': 'bg-green-500',
            'Blue': 'bg-blue-600',
            'Indigo': 'bg-indigo-600',
            'Violet': 'bg-purple-600',
            'Black': 'bg-black'
        };
        let selectedColor = COLORS['Red'];
        
        // --- Drag State Variables ---
        let isDragging = false;
        let activeTileElement = null;
        let offsetX = 0;
        let offsetY = 0;
        
        // Tile dimensions (for bounds checking)
        const TILE_SIZE_SM = 192; // w-48
        const TILE_SIZE_LG = 224; // sm:w-56 

        /**
         * Returns the correct tile size based on the current viewport.
         */
        function getCurrentTileSize() {
            return window.innerWidth >= 640 ? TILE_SIZE_LG : TILE_SIZE_SM;
        }
        
        // --- Drag Handlers ---

        function handleDragStart(e) {
            // Only start drag if it's the element itself
            if (e.target.id !== 'my-tile') return;

            e.preventDefault(); 
            isDragging = true;
            activeTileElement = e.currentTarget; 
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = activeTileElement.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;
        }

        function handleDragMove(e) {
            if (!isDragging || !activeTileElement) return;
            
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let newLeft = clientX - offsetX;
            let newTop = clientY - offsetY;

            // --- BOUNDARY CONSTRAINT LOGIC ---
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const elementW = activeTileElement.offsetWidth;
            const elementH = activeTileElement.offsetHeight;

            // Clamp positions to stay within bounds
            newLeft = Math.max(0, Math.min(newLeft, viewportW - elementW));
            newTop = Math.max(0, Math.min(newTop, viewportH - elementH));
            // --- END BOUNDARY LOGIC ---

            // Apply the constrained position
            activeTileElement.style.left = `${newLeft}px`;
            activeTileElement.style.top = `${newTop}px`;
            
            // Update local state (for use if we re-render or resize)
            localTileData.left = activeTileElement.style.left;
            localTileData.top = activeTileElement.style.top;
        }

        function handleDragEnd() {
            if (!isDragging) return;
            isDragging = false;
            activeTileElement = null; 
        }

        // Attach global document listeners for drag movement/end 
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchmove', handleDragMove, { passive: false }); 
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);

        // --- Core Functions ---

        /**
         * Renders the single tile DOM element based on localTileData.
         */
        function renderTile() {
            // Remove prompt if it exists
            const inputPrompt = document.getElementById('input-prompt');
            if(inputPrompt) {
                inputPrompt.remove();
                canvasContainer.className = 'absolute inset-0 w-full h-full';
            }

            if (!localTileData) return;
            
            const tileData = localTileData;
            const domId = 'my-tile';
            let tileElement = document.getElementById(domId);

            if (!tileElement) {
                tileElement = document.createElement('div');
                tileElement.id = domId;
                tileElement.classList.add('draggable-tile'); 
                canvasContainer.appendChild(tileElement);
                
                // Attach listeners
                tileElement.onmousedown = handleDragStart;
                tileElement.ontouchstart = handleDragStart;
            }

            // Apply styling classes
            const colorClass = tileData.color;

            tileElement.className = `w-48 h-48 sm:w-56 sm:h-56 shadow-xl rounded-lg ${colorClass}`;
            tileElement.classList.add('draggable-tile'); // Re-add after clearing className

            // Determine text color for contrast
            const isLightColor = colorClass.includes('yellow') || colorClass.includes('400');
            const textColor = isLightColor ? 'text-gray-800' : 'text-white';
            
            // Set the contents 
            tileElement.innerHTML = `
                <div id="my-tile" class="h-full w-full flex flex-col justify-center items-center p-4">
                    <h2 class="text-3xl font-extrabold tracking-tight ${textColor} text-center select-none pointer-events-none">
                        ${tileData.name}
                    </h2>
                    <p class="text-sm italic font-normal ${textColor} opacity-80 mt-2 select-none pointer-events-none">
                        Created: ${tileData.createdAt}
                    </p>
                </div>
            `;
            
            // Apply position
            tileElement.style.left = tileData.left; 
            tileElement.style.top = tileData.top; 
        }

        /**
         * Renders the name and color input prompt screen.
         */
        function renderInputPrompt() {
            // Don't render if a tile already exists
            if (localTileData) return;
            
            // Clear canvas and set to centered view
            canvasContainer.innerHTML = '';
            canvasContainer.className = 'w-full centered-input-view';
            
            const promptDiv = document.createElement('div');
            promptDiv.id = 'input-prompt';
            promptDiv.className = 'w-full max-w-xs mx-4 p-6 bg-white shadow-xl rounded-xl';

            // Generate color swatch HTML
            const colorSwatches = Object.entries(COLORS).map(([name, colorClass]) => `
                <button type="button" data-color="${colorClass}" 
                    class="color-swatch w-7 h-7 rounded-full shadow-md hover:ring-4 hover:ring-offset-2 hover:ring-gray-300 ${colorClass} transition duration-150 ease-in-out" 
                    title="${name}"
                ></button>
            `).join('');

            promptDiv.innerHTML = `
                <div class="space-y-4">
                    <p class="text-xl font-bold text-gray-800 text-center">Create Your Tile</p>

                    <input
                        type="text"
                        id="name-input"
                        placeholder="Enter your name or greeting"
                        class="w-full px-3 py-2 border border-gray-400 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                        autocomplete="off"
                        autofocus
                        maxlength="15"
                    >
                    
                    <div class="flex flex-col space-y-2">
                        <p class="text-sm font-medium text-gray-600 text-center">Choose a Color</p>
                        <div id="color-picker" class="flex justify-between items-center px-2">
                            ${colorSwatches}
                        </div>
                    </div>

                    <button
                        id="submit-button"
                        class="w-full bg-blue-600 text-white py-2 rounded-lg font-medium hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-md"
                        disabled
                    >
                        Create Tile
                    </button>
                </div>
            `;
            canvasContainer.appendChild(promptDiv);

            const input = document.getElementById('name-input');
            const button = document.getElementById('submit-button');
            const colorPicker = document.getElementById('color-picker');

            const applyRing = (colorClass) => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('ring-gray-900', 'ring-2'));
                const currentSwatch = document.querySelector(`[data-color="${colorClass}"]`);
                if (currentSwatch) {
                    currentSwatch.classList.add('ring-gray-900', 'ring-2');
                }
            };
            
            applyRing(selectedColor);

            colorPicker.addEventListener('click', (e) => {
                const swatch = e.target.closest('.color-swatch');
                if (swatch) {
                    selectedColor = swatch.dataset.color;
                    applyRing(selectedColor);
                }
            });

            input.addEventListener('input', () => {
                const name = input.value.trim();
                button.disabled = name.length === 0;
            });

            const createNewTile = () => {
                const name = input.value.trim();
                if (!name || name.length === 0) return;

                const creationDate = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                // Calculate Initial Centered Pixel Position
                const size = getCurrentTileSize();
                const initialLeft = `${(window.innerWidth / 2) - (size / 2)}px`;
                const initialTop = `${(window.innerHeight / 2) - (size / 2)}px`;
                
                localTileData = {
                    name: name,
                    color: selectedColor,
                    left: initialLeft,
                    top: initialTop,
                    createdAt: creationDate 
                };

                // Render the tile and hide the prompt
                renderTile();
            };

            button.addEventListener('click', createNewTile);
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !button.disabled) {
                    createNewTile();
                }
            });
            input.focus();
        }

        /**
         * Initialization function
         */
        function initializeApp() {
            renderInputPrompt();
        }

        // Initialize on load
        window.onload = initializeApp;
        
        // Re-render on resize to maintain correct drag behavior (not strictly necessary but good practice)
        window.addEventListener('resize', renderTile); 
    </script>
</body>
</html>
