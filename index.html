<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Tile Persistence Test</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght=100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f3f6;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll when tile is near edge */
        }
        .centered-input-view {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .draggable-tile {
            position: absolute;
            user-select: none;
            cursor: grab;
            transition: box-shadow 0.3s ease;
        }
        .draggable-tile:active {
            cursor: grabbing;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); /* Larger shadow when grabbing */
        }
    </style>
</head>
<body>
    
    <!-- Main container for the draggable element -->
    <section id="canvas-container" class="absolute inset-0 w-full h-full flex justify-center items-center">
        <!-- Tile or Input Prompt Renders here -->
        <div id="loading-state" class="text-gray-600 text-lg">
            Loading authentication...
        </div>
    </section>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Setup (Using global variables provided by the environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        let app;
        let db;
        let auth;
        let userId = null; // Will remain null if Auth fails
        let tileDocId = 'user_tile_doc'; // Fixed document ID for the single user tile
        
        // Initialize Firebase services immediately (non-blocking setup)
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug');
        } else {
            console.error("FATAL: Firebase configuration is missing.");
        }
        
        // --- Global State ---
        const canvasContainer = document.getElementById('canvas-container');
        let localTileData = null; // Stores the single tile data retrieved from Firestore.
        const MAX_DRAG_SESSIONS = 6;
        const COOLDOWN_DURATION_MS = 60000;
        let cooldownIntervalId = null; 
        
        const COLORS = {
            'Red': 'bg-red-500',
            'Orange': 'bg-orange-500',
            'Yellow': 'bg-yellow-400',
            'Green': 'bg-green-500',
            'Blue': 'bg-blue-600',
            'Indigo': 'bg-indigo-600',
            'Violet': 'bg-purple-600',
            'Black': 'bg-black'
        };
        let selectedColor = COLORS['Red'];
        
        // --- Drag State Variables ---
        let isDragging = false;
        let activeTileElement = null;
        let offsetX = 0;
        let offsetY = 0;
        
        const TILE_SIZE_SM = 192; 
        const TILE_SIZE_LG = 224; 

        // --- Utility Functions ---

        function getCurrentTileSize() {
            return window.innerWidth >= 640 ? TILE_SIZE_LG : TILE_SIZE_SM;
        }

        function getTileDocRef() {
            if (!db || !userId) return null;
            // Document path: /artifacts/{appId}/users/{userId}/tiles/{documentId}
            return doc(db, 'artifacts', appId, 'users', userId, 'tiles', tileDocId); 
        }

        async function saveTile(data) {
            const tileRef = getTileDocRef();
            if (tileRef) {
                try {
                    await setDoc(tileRef, data, { merge: true });
                } catch (error) {
                    console.error("Error saving tile data:", error);
                }
            } else {
                 console.warn("Save requested, but no valid userId/db connection. Data will be non-persistent.");
            }
        }
        
        // --- Data Listener and Auth Setup ---

        function startDataListener() {
            const tileRef = getTileDocRef();
            if (tileRef) {
                // Set up real-time listener
                onSnapshot(tileRef, (docSnap) => {
                    if (docSnap.exists()) {
                        // Tile exists in Firestore, update local state and render
                        localTileData = docSnap.data();
                        renderTile();
                    } else {
                        // Tile does not exist, show creation prompt (if not already showing)
                        localTileData = null;
                        if (!document.getElementById('input-prompt')) {
                             renderInputPrompt();
                        }
                    }
                }, (error) => {
                    console.error("Error listening to tile data:", error);
                });
            }
        }
        
        /**
         * Starts non-blocking authentication in the background.
         * Only updates userId and starts listener if successful, does not block UI render.
         */
        async function setupAuthAndData() {
            if (!auth || !db) return; // Skip if Firebase init failed

            // Set up the listener first. This will capture the sign-in result.
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // Auth was successful! Update state and start listening to persistent data.
                    userId = user.uid;
                    startDataListener(); 
                    // Re-render the prompt/tile to update the userId displayed
                    if(document.getElementById('input-prompt')) renderInputPrompt();
                    else if (localTileData) renderTile();
                    
                } else {
                    // Auth resolved but user is signed out or anonymous sign-in failed.
                    userId = null; 
                    // If the user was previously authenticated but signed out, this will trigger the Firestore listener to stop.
                }
            });
            
            // Attempt sign-in (non-blocking)
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token.length > 0) {
                    signInWithCustomToken(auth, __initial_auth_token)
                        .catch(error => console.error("Custom Sign-in Failed (non-blocking):", error));
                } else {
                    signInAnonymously(auth)
                        .catch(error => console.error("Anonymous Sign-in Failed (non-blocking):", error));
                }
            } catch (error) {
                console.error("Firebase Sign-in Attempt Error (sync):", error);
            }
        }
        
        // --- Drag Handlers (omitted for brevity, no changes) ---
        
        function handleDragStart(e) {
            if (localTileData && localTileData.movesMade >= MAX_DRAG_SESSIONS && localTileData.moveRestrictionEndTime > Date.now()) {
                return;
            }
            if (e.target.id !== 'my-tile') return;

            e.preventDefault(); 
            isDragging = true;
            activeTileElement = e.currentTarget; 
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = activeTileElement.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;
        }

        function handleDragMove(e) {
            if (!isDragging || !activeTileElement) return;
            
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let newLeft = clientX - offsetX;
            let newTop = clientY - offsetY;

            // --- BOUNDARY CONSTRAINT LOGIC ---
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const elementW = activeTileElement.offsetWidth;
            const elementH = activeTileElement.offsetHeight;

            newLeft = Math.max(0, Math.min(newLeft, viewportW - elementW));
            newTop = Math.max(0, Math.min(newTop, viewportH - elementH));
            // --- END BOUNDARY LOGIC ---

            activeTileElement.style.left = `${newLeft}px`;
            activeTileElement.style.top = `${newTop}px`;
        }

        function finalizeMove() {
            if (!localTileData) return;
            
            if (localTileData.movesMade >= MAX_DRAG_SESSIONS && localTileData.moveRestrictionEndTime > Date.now()) {
                return;
            }
            
            const newMovesMade = localTileData.movesMade + 1;
            let newRestrictionEndTime = localTileData.moveRestrictionEndTime;
            
            if (newMovesMade >= MAX_DRAG_SESSIONS) {
                newRestrictionEndTime = Date.now() + COOLDOWN_DURATION_MS; 
            }

            // Save to Firestore if connected, otherwise update local state only
            if (userId) {
                saveTile({
                    movesMade: newMovesMade,
                    moveRestrictionEndTime: newRestrictionEndTime,
                    left: activeTileElement.style.left,
                    top: activeTileElement.style.top,
                });
            } else {
                localTileData.movesMade = newMovesMade;
                localTileData.moveRestrictionEndTime = newRestrictionEndTime;
                localTileData.left = activeTileElement.style.left;
                localTileData.top = activeTileElement.style.top;
                renderTile(); // Force a manual re-render if not using Firestore snapshot
            }
        }

        function handleDragEnd() {
            if (!isDragging) return;
            
            if (activeTileElement) {
                finalizeMove();
            }
            
            isDragging = false;
            activeTileElement = null; 
        }

        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchmove', handleDragMove, { passive: false }); 
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('touchcancel', handleDragEnd);


        // --- Rendering Functions ---

        /**
         * Renders the single tile DOM element based on localTileData.
         */
        function renderTile() {
            if (cooldownIntervalId) {
                clearInterval(cooldownIntervalId);
                cooldownIntervalId = null;
            }

            const inputPrompt = document.getElementById('input-prompt');
            if(inputPrompt) {
                inputPrompt.remove();
            }

            if (!localTileData) {
                return; 
            }
            
            const tileData = localTileData;
            const domId = 'my-tile';
            let tileElement = document.getElementById(domId);

            if (!tileElement) {
                tileElement = document.createElement('div');
                tileElement.id = domId;
                tileElement.classList.add('draggable-tile'); 
                canvasContainer.appendChild(tileElement);
                canvasContainer.classList.remove('centered-input-view');
            }
            
            // --- MOVES LEFT & COOLDOWN LOGIC ---
            let movesLeft = MAX_DRAG_SESSIONS - tileData.movesMade;
            const isCooldownExpired = tileData.moveRestrictionEndTime > 0 && Date.now() >= tileData.moveRestrictionEndTime;
            
            if (isCooldownExpired) {
                if (tileData.moveRestrictionEndTime > 0 && userId) { // Only attempt reset save if connected
                    saveTile({ movesMade: 0, moveRestrictionEndTime: 0 });
                }
                movesLeft = MAX_DRAG_SESSIONS;
            }
            
            const isRestricted = tileData.movesMade >= MAX_DRAG_SESSIONS && tileData.moveRestrictionEndTime > Date.now();
            let movesDisplayText = isRestricted ? 'COOLDOWN: initializing...' : `Moves Left: ${movesLeft} of ${MAX_DRAG_SESSIONS}`;
            // --- END MOVES LEFT & COOLDOWN LOGIC ---

            // Apply styling
            const colorClass = tileData.color;
            tileElement.className = `w-48 h-48 sm:w-56 sm:h-56 shadow-xl rounded-lg ${colorClass}`;
            tileElement.classList.add('draggable-tile');

            const isLightColor = colorClass.includes('yellow') || colorClass.includes('400');
            const textColor = isLightColor ? 'text-gray-800' : 'text-white';
            
            tileElement.innerHTML = `
                <div id="my-tile" class="h-full w-full flex flex-col justify-center items-center p-4">
                    <h2 class="text-3xl font-extrabold tracking-tight ${textColor} text-center select-none pointer-events-none">
                        ${tileData.name}
                    </h2>
                    <p class="text-sm italic font-normal ${textColor} opacity-80 mt-2 select-none pointer-events-none">
                        Created: ${tileData.createdAt}
                    </p>
                    <p class="text-xs font-mono text-center mt-2 font-bold ${textColor} opacity-100 pointer-events-none" id="moves-display-text">
                        ${movesDisplayText}
                    </p>
                    <p class="text-xs font-mono text-center mt-1 ${textColor} opacity-60 pointer-events-none break-all text-ellipsis overflow-hidden">
                        ${userId ? 'USER ID: ' + userId : 'NON-PERSISTENT SESSION'}
                    </p>
                </div>
            `;
            
            // Set up dynamic display and interval if restricted
            if (isRestricted) {
                const movesDisplayElement = tileElement.querySelector('#moves-display-text');

                const updateRestrictionDisplay = () => {
                    const now = Date.now();
                    const timeRemaining = tileData.moveRestrictionEndTime - now;

                    if (timeRemaining <= 0) {
                        clearInterval(cooldownIntervalId);
                        renderTile(); 
                        return;
                    }

                    const secondsTotal = Math.ceil(timeRemaining / 1000);
                    const minutes = Math.floor(secondsTotal / 60);
                    const seconds = secondsTotal % 60;
                    
                    const displayTime = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    
                    if(movesDisplayElement) {
                        movesDisplayElement.textContent = `COOLDOWN: ${displayTime}`;
                    }
                };
                
                updateRestrictionDisplay(); 
                cooldownIntervalId = setInterval(updateRestrictionDisplay, 1000);
                
                // Disable handlers and apply visual cues
                tileElement.onmousedown = null;
                tileElement.ontouchstart = null;
                tileElement.style.cursor = 'default';
                tileElement.classList.add('opacity-75', 'cursor-not-allowed'); 
            } else {
                // Ensure handlers are active
                tileElement.onmousedown = handleDragStart;
                tileElement.ontouchstart = handleDragStart;
                tileElement.style.cursor = 'grab';
                tileElement.classList.remove('opacity-75', 'cursor-not-allowed');
            }

            // Apply position
            tileElement.style.left = tileData.left; 
            tileElement.style.top = tileData.top; 
        }

        /**
         * Renders the name and color input prompt screen.
         */
        function renderInputPrompt() {
            if (document.getElementById('my-tile')) {
                document.getElementById('my-tile').remove();
            }
            canvasContainer.innerHTML = '';
            canvasContainer.className = 'w-full centered-input-view';
            
            const promptDiv = document.createElement('div');
            promptDiv.id = 'input-prompt';
            promptDiv.className = 'w-full max-w-xs mx-4 p-6 bg-white shadow-xl rounded-xl';

            const colorSwatches = Object.entries(COLORS).map(([name, colorClass]) => `
                <button type="button" data-color="${colorClass}" 
                    class="color-swatch w-7 h-7 rounded-full shadow-md hover:ring-4 hover:ring-offset-2 hover:ring-gray-300 ${colorClass} transition duration-150 ease-in-out" 
                    title="${name}"
                ></button>
            `).join('');

            promptDiv.innerHTML = `
                <div class="space-y-4">
                    <p class="text-xl font-bold text-gray-800 text-center">Create Your Tile</p>
                    <p class="text-xs text-center text-gray-500 break-all text-ellipsis overflow-hidden" id="user-status-text">
                        ${userId ? 'USER ID: ' + userId : 'Status: Trying to connect for persistence...'}
                    </p>

                    <input
                        type="text"
                        id="name-input"
                        placeholder="Enter your name or greeting"
                        class="w-full px-3 py-2 border border-gray-400 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                        autocomplete="off"
                        autofocus
                        maxlength="15"
                    >
                    
                    <div class="flex flex-col space-y-2">
                        <p class="text-sm font-medium text-gray-600 text-center">Choose a Color</p>
                        <div id="color-picker" class="flex justify-between items-center px-2">
                            ${colorSwatches}
                        </div>
                    </div>

                    <button
                        id="submit-button"
                        class="w-full bg-blue-600 text-white py-2 rounded-lg font-medium hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-md"
                        disabled
                    >
                        Create Tile
                    </button>
                </div>
            `;
            canvasContainer.appendChild(promptDiv);

            const input = document.getElementById('name-input');
            const button = document.getElementById('submit-button');
            const colorPicker = document.getElementById('color-picker');
            const userStatusText = document.getElementById('user-status-text');

            const applyRing = (colorClass) => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('ring-gray-900', 'ring-2'));
                const currentSwatch = document.querySelector(`[data-color="${colorClass}"]`);
                if (currentSwatch) {
                    currentSwatch.classList.add('ring-gray-900', 'ring-2');
                }
            };
            
            applyRing(selectedColor);

            colorPicker.addEventListener('click', (e) => {
                const swatch = e.target.closest('.color-swatch');
                if (swatch) {
                    selectedColor = swatch.dataset.color;
                    applyRing(selectedColor);
                }
            });

            input.addEventListener('input', () => {
                const name = input.value.trim();
                button.disabled = name.length === 0; 
            });
            input.dispatchEvent(new Event('input')); 


            const createNewTile = () => {
                const name = input.value.trim();
                if (!name || name.length === 0) return;

                const creationDate = new Date().toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
                
                const size = getCurrentTileSize();
                const initialLeft = `${(window.innerWidth / 2) - (size / 2)}px`;
                const initialTop = `${(window.innerHeight / 2) - (size / 2)}px`;
                
                const newTileData = {
                    name: name,
                    color: selectedColor,
                    left: initialLeft,
                    top: initialTop,
                    createdAt: creationDate,
                    userId: userId, 
                    movesMade: 0, 
                    moveRestrictionEndTime: 0,
                };

                // Save to Firestore if authenticated, otherwise render locally
                if (userId) {
                    saveTile(newTileData);
                } else {
                    // Fallback: local session only
                    localTileData = newTileData;
                    renderTile();
                }
            };

            button.addEventListener('click', createNewTile);
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !button.disabled) {
                    createNewTile();
                }
            });
            input.focus();
        }
        
        // --- Execution Flow: Guaranteed Instant Render ---
        
        window.onload = function () {
            // 1. Immediately remove the blocking loading screen
            const loadingState = document.getElementById('loading-state');
            if (loadingState) loadingState.remove();

            // 2. Render the interactive UI prompt immediately
            renderInputPrompt();

            // 3. Start the non-blocking authentication in the background
            if (db) {
                setupAuthAndData();
            } else {
                const statusText = document.getElementById('user-status-text');
                if (statusText) statusText.textContent = "Status: Firebase connection failed.";
            }

            // 4. Ensure responsiveness
            window.addEventListener('resize', renderTile); 
        };
        
    </script>
</body>
</html>
